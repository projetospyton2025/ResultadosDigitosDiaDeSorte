<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Palpites Baseado em dígitos- Dia de Sorte</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                    }
                }
            },
            darkMode: 'class',
        }
    </script>
    <style>
        @media print {
            .no-print {
                display: none;
            }
            .page-break {
                page-break-after: always;
            }
        }
        
        footer {
                color: #161515;
                text-align: center;
                padding: 5px;
                margin-bottom: auto;
                margin-top: 10px; /* Espaço acima do rodapé */
        }
        .small{
                font-size: 16px;
                font-style: italic;
        }
        
        .toggle-btn {
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        
        .toggle-btn.active {
            transform: rotate(180deg);
        }
        
        .transition-height {
            transition: max-height 0.5s ease-out;
            overflow: hidden;
        }
        
        .number-low {
            background-color: rgba(134, 239, 172, 0.9);
            color: rgb(22, 101, 52);
        }
        
        .dark .number-low {
            background-color: rgba(22, 101, 52, 0.7);
            color: rgb(187, 247, 208);
        }
        
        .number-medium {
            background-color: rgba(253, 230, 138, 0.9);
            color: rgb(146, 64, 14);
        }
        
        .dark .number-medium {
            background-color: rgba(146, 64, 14, 0.7);
            color: rgb(254, 240, 138);
        }
        
        .number-high {
            background-color: rgba(252, 165, 165, 0.9);
            color: rgb(153, 27, 27);
        }
        
        .dark .number-high {
            background-color: rgba(153, 27, 27, 0.7);
            color: rgb(254, 202, 202);
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-800 dark:text-gray-200 min-h-screen">
    <!-- Dark mode detection -->
    <script>
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });
    </script>

    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold text-center text-primary mb-6">Gerador de Palpites - Dia de Sorte</h1>
        
        <div class="flex flex-col md:flex-row gap-4 mb-6">
            <div class="w-full md:w-1/2">
                <h2 class="text-xl font-semibold mb-2">Combinações de Dígitos <span class="small">(126 combinações de dígitos)</span></h2>
                <textarea id="digitCombinations" rows="6" class="w-full p-2 border rounded dark:bg-gray-800 dark:border-gray-700 text-base" readonly></textarea>
            </div>
            
            <div class="w-full md:w-1/2">
                <h2 class="text-xl font-semibold mb-2">Configurações</h2>
                <div class="space-y-4 bg-gray-100 dark:bg-gray-800 p-4 rounded">
                    <div>
                        <label class="block mb-1">Quantidade de dezenas por palpite:</label>
                        <input type="number" id="numberPerBet" value="8" min="7" max="15" class="p-2 border rounded w-full dark:bg-gray-700 dark:border-gray-600 text-base">
                    </div>
                    <div>
                        <label class="block mb-1">Número máximo permitido:</label>
                        <input type="number" id="maxNumber" value="31" min="1" max="31" class="p-2 border rounded w-full dark:bg-gray-700 dark:border-gray-600 text-base">
                    </div>
                    <div>
                        <label class="block mb-1">Distribuição por faixa:</label>
                        <div class="flex flex-wrap gap-2">
                            <div class="flex items-center gap-1">
                                <label for="lowRange" class="whitespace-nowrap">Baixas (1-10):</label>
                                <input type="number" id="lowRange" value="3" min="1" max="7" class="p-2 border rounded w-14 dark:bg-gray-700 dark:border-gray-600 text-base">
                            </div>
                            <div class="flex items-center gap-1">
                                <label for="mediumRange" class="whitespace-nowrap">Médias (11-20):</label>
                                <input type="number" id="mediumRange" value="3" min="1" max="7" class="p-2 border rounded w-14 dark:bg-gray-700 dark:border-gray-600 text-base">
                            </div>
                            <div class="flex items-center gap-1">
                                <label for="highRange" class="whitespace-nowrap">Altas (21-31):</label>
                                <input type="number" id="highRange" value="2" min="1" max="7" class="p-2 border rounded w-14 dark:bg-gray-700 dark:border-gray-600 text-base">
                            </div>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button id="generateBtn" class="bg-primary hover:bg-primary/90 text-white font-bold py-2 px-4 rounded">
                            Gerar Palpites
                        </button>
                        <button id="printBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">
                            Imprimir
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="mb-6">
            <h2 class="text-xl font-semibold mb-2">Análise de Frequência de Resultados Anteriores</h2>
            <div class="bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded p-4">
                <div class="mb-4">
                    <label class="block mb-1">Cole os resultados do Dia de Sorte (um por linha, números separados por espaço):</label>
                    <textarea id="historicalResults" rows="6" placeholder="Ex: 01 03 07 13 18 27 29 
04 07 09 10 14 20 25" class="w-full p-2 border rounded dark:bg-gray-800 dark:border-gray-700 text-base"></textarea>
                </div>
                <div class="flex flex-wrap gap-2 mb-4">
                    <button id="analyzeBtn" class="bg-primary hover:bg-primary/90 text-white font-bold py-2 px-4 rounded">
                        Analisar Frequência
                    </button>
                    <div class="flex flex-col sm:flex-row gap-2 flex-grow">
                        <select id="apiSelect" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 text-base flex-grow">
                            <option value="auto">Auto (Testar Todas as APIs)</option>
                            <option value="caixa">API Caixa Oficial</option>
                            <option value="heroku">API Heroku</option>
                            <option value="brasilapi">API Brasil</option>
                        </select>
                        <select id="modeSelect" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 text-base">
                            <option value="direct">Acesso Direto</option>
                            <option value="proxy">Via Proxy CORS</option>
                            <option value="both">Tentar Ambos</option>
                        </select>
                    </div>
                    <input type="number" id="concursoNum" placeholder="Nº do concurso (opcional)" min="1" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 text-base w-48">
                    <button id="fetchResultsBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded flex items-center">
                        <span id="fetchText">Buscar Resultados</span>
                        <svg id="loadingSpinner" class="animate-spin ml-2 h-4 w-4 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </button>
                </div>
                <div id="apiStatus" class="mb-4 p-3 bg-gray-100 dark:bg-gray-700 rounded hidden">
                    <div class="font-semibold mb-1">Status da busca:</div>
                    <div id="apiStatusContent" class="text-sm"></div>
                </div>
                <div id="frequencyAnalysis" class="mt-4">
                    <div id="frequencyResults" class="hidden">
                        <h3 class="text-lg font-semibold mb-2">Frequência de Dígitos</h3>
                        <div id="topCombinations" class="bg-gray-100 dark:bg-gray-700 p-3 rounded mb-3">
                            <!-- Será preenchido com as combinações mais frequentes -->
                        </div>
                        
                        <!-- Novo painel para combinações não sorteadas -->
                        <div id="undrawnCombinations" class="bg-blue-100 dark:bg-blue-900 p-3 rounded mb-3">
                            <div class="font-bold text-xl mb-3 text-blue-800 dark:text-blue-200">Combinações Ainda Não Sorteadas</div>
                            <div id="undrawnCombinationsContent" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2">
                                <!-- Será preenchido com as combinações não sorteadas -->
                            </div>
                            <div class="mt-3 flex justify-end">
                                <button id="downloadUndrawnBtn" class="bg-blue-600 hover:bg-blue-700 text-white text-sm font-bold py-1 px-3 rounded">
                                    Baixar Lista
                                </button>
                            </div>
                        </div>
                        
                        <div class="overflow-x-auto">
                            <table class="min-w-full divide-y divide-gray-300 dark:divide-gray-700">
                                <thead>
                                    <tr class="bg-gray-100 dark:bg-gray-700">
                                        <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Combinação de Dígitos</th>
                                        <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Frequência</th>
                                        <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Porcentagem</th>
                                    </tr>
                                </thead>
                                <tbody id="frequencyTableBody" class="divide-y divide-gray-200 dark:divide-gray-700">
                                    <!-- Será preenchido dinamicamente -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="mb-8">
            <div class="flex items-center justify-between cursor-pointer mb-2" id="combinationsToggleHeader">
                <h2 class="text-xl font-semibold">Tabela de Combinações</h2>
                <svg class="h-6 w-6 text-gray-500 dark:text-gray-400 toggle-btn" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
            <div id="combinationsTableContainer" class="transition-height bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded overflow-x-auto" style="max-height: 0px;">
                <div id="combinationsTable">
                    <table class="min-w-full divide-y divide-gray-300 dark:divide-gray-700">
                        <thead>
                            <tr class="bg-gray-100 dark:bg-gray-700">
                                <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Dígitos</th>
                                <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Números Possíveis</th>
                                <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Total</th>
                            </tr>
                        </thead>
                        <tbody id="combinationsTableBody" class="divide-y divide-gray-200 dark:divide-gray-700">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="mb-8">
            <h2 class="text-xl font-semibold mb-2">Resumo Estatístico</h2>
            <div id="statisticsSummary" class="bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded p-4">
                <div id="statisticsContent" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Dynamic content will be inserted here -->
                </div>
                <div id="statisticsTotal" class="mt-4 font-bold border-t pt-2 dark:border-gray-700">
                    <!-- Total will be inserted here -->
                </div>
            </div>
        </div>

        <!-- Nova seção para geração de todos os palpites para uma combinação específica -->
        <div class="mb-8">
            <h2 class="text-xl font-semibold mb-4">Gerador por Combinação Específica</h2>
            <div class="bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded p-4">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="block mb-2">Selecione uma combinação de dígitos:</label>
                        <select id="specificCombination" class="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 text-base">
                            <!-- Será preenchido dinamicamente -->
                        </select>
                    </div>
                    <div>
                        <label class="block mb-2">Dezenas por palpite:</label>
                        <div class="flex gap-4">
                            <input type="number" id="specificNumberPerBet" value="7" min="5" max="15" class="p-2 border rounded w-full dark:bg-gray-700 dark:border-gray-600 text-base">
                            <button id="generateSpecificBtn" class="bg-primary hover:bg-primary/90 text-white font-bold py-2 px-4 rounded whitespace-nowrap">
                                Gerar Palpites
                            </button>
                        </div>
                    </div>
                </div>

                <div class="mb-4">
                    <div class="bg-gray-100 dark:bg-gray-700 p-3 rounded">
                        <div class="font-semibold mb-2">Dezenas possíveis para esta combinação:</div>
                        <div id="possibleNumbersDisplay" class="flex flex-wrap gap-2"></div>
                    </div>
                </div>

                <div class="mb-4 flex flex-wrap gap-2 justify-between items-center">
                    <div>
                        <span class="font-semibold">Total de palpites gerados: </span>
                        <span id="specificBetCount" class="bg-primary/10 dark:bg-primary/20 text-primary px-2 py-1 rounded-full font-bold">0</span>
                    </div>
                    <div class="flex gap-2">
                        <button id="downloadSpecificBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded flex items-center disabled:opacity-50 disabled:cursor-not-allowed">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                            </svg>
                            Baixar Palpites
                        </button>
                    </div>
                </div>

                <div id="specificBetsResults" class="border-t dark:border-gray-700 pt-4">
                    <div id="specificResultsContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Resultados dinâmicos serão mostrados aqui -->
                    </div>
                    
                    <!-- Paginação -->
                    <div id="paginationContainer" class="mt-6 flex justify-center items-center space-x-2">
                        <button id="prevPageBtn" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                            Anterior
                        </button>
                        <span id="paginationInfo" class="text-sm px-2">Página 1 de 1</span>
                        <button id="nextPageBtn" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                            Próxima
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div id="results" class="mt-6">
            <h2 class="text-xl font-semibold mb-4">Palpites Gerados (<span id="totalBetsCount">0</span> palpites)</h2>
            
            <div class="mb-4 flex flex-wrap gap-2 justify-between items-center">
                <div class="flex flex-wrap gap-2">
                    <div class="bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 px-3 py-1 rounded-full text-sm font-medium">
                        Baixas (1-10): <span id="lowCount">0</span>
                    </div>
                    <div class="bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 px-3 py-1 rounded-full text-sm font-medium">
                        Médias (11-20): <span id="mediumCount">0</span>
                    </div>
                    <div class="bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200 px-3 py-1 rounded-full text-sm font-medium">
                        Altas (21-31): <span id="highCount">0</span>
                    </div>
                </div>
                <div class="flex gap-2">
                    <button id="downloadSimpleBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                        Somente Dezenas
                    </button>
                    <button id="downloadBtn" class="bg-primary hover:bg-primary/90 text-white font-bold py-2 px-4 rounded flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                        Baixar Detalhado
                    </button>
                </div>
            </div>
            
            <div class="mb-4">
                <div class="flex border-b dark:border-gray-700">
                    <button id="allBetsTab" class="py-2 px-4 font-medium border-b-2 border-primary text-primary">Todos</button>
                    <button id="lowBetsTab" class="py-2 px-4 font-medium text-gray-600 dark:text-gray-400">Baixas</button>
                    <button id="mediumBetsTab" class="py-2 px-4 font-medium text-gray-600 dark:text-gray-400">Médias</button>
                    <button id="highBetsTab" class="py-2 px-4 font-medium text-gray-600 dark:text-gray-400">Altas</button>
                </div>
            </div>
            
            <div id="bettingResults" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <!-- Dynamic content will be inserted here -->
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Configurações das APIs
            const API_CONFIG = {
                // APIs oficiais
                CAIXA_URL: 'https://servicebus2.caixa.gov.br/portaldeloterias/api/diadesorte',
                HEROKU_URL: 'https://loteriascaixa-api.herokuapp.com/api/dia-de-sorte',
                BRASIL_URL: 'https://brasilapi.com.br/api/loterias/v1/dia-de-sorte',
                
                // Serviços de proxy CORS
                CORS_PROXY_URLS: [
                    'https://corsproxy.io/?',
                    'https://api.allorigins.win/raw?url=',
                    'https://cors-anywhere.herokuapp.com/'
                ]
            };
            
            // Armazenamento de cache local para dados das APIs
            const LOCAL_CACHE = {
                setCached: function(key, data, expiresInMinutes = 60) {
                    try {
                        const item = {
                            data: data,
                            expires: new Date().getTime() + expiresInMinutes * 60 * 1000
                        };
                        localStorage.setItem(key, JSON.stringify(item));
                        return true;
                    } catch (e) {
                        console.error("Erro ao armazenar em cache:", e);
                        return false;
                    }
                },
                
                getCached: function(key) {
                    try {
                        const item = JSON.parse(localStorage.getItem(key));
                        if (!item) return null;
                        
                        // Verifica se expirou
                        if (new Date().getTime() > item.expires) {
                            localStorage.removeItem(key);
                            return null;
                        }
                        
                        return item.data;
                    } catch (e) {
                        console.error("Erro ao recuperar cache:", e);
                        return null;
                    }
                }
            };

            // Função para gerar TODAS as combinações possíveis de 5 dígitos
            function generateAllDigitCombinations() {
                const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
                const combinations = [];
                
                // Função auxiliar para gerar combinações de k elementos de um array
                function combinate(arr, k, startIndex, currentCombination, result) {
                    if (currentCombination.length === k) {
                        result.push([...currentCombination]);
                        return;
                    }
                    
                    for (let i = startIndex; i < arr.length; i++) {
                        currentCombination.push(arr[i]);
                        combinate(arr, k, i + 1, currentCombination, result);
                        currentCombination.pop();
                    }
                }
                
                // Gerar combinações de 5 dígitos
                combinate(digits, 5, 0, [], combinations);
                
                // Converter para formato de string (ex: "0,1,2,3,4")
                return combinations.map(combo => combo.join(','));
            }

            // Função para filtrar combinações inválidas para Dia de Sorte
            function filterValidCombinations(allCombinations) {
                // Apenas 126 das 252 combinações são válidas para o Dia de Sorte
                // Esta é apenas uma implementação de exemplo - a lógica real depende das regras específicas
                // Retornamos as mesmas 126 combinações que o usuário forneceu
                
                const validCombinations = [
                    "0,1,2,3,4", "0,1,2,3,5", "0,1,2,3,6", "0,1,2,3,7", "0,1,2,3,8", "0,1,2,3,9", 
                    "0,1,2,4,5", "0,1,2,4,6", "0,1,2,4,7", "0,1,2,4,8", "0,1,2,4,9", "0,1,2,5,6",     
                    "0,1,2,5,7", "0,1,2,5,8", "0,1,2,5,9", "0,1,2,6,7", "0,1,2,6,8", "0,1,2,6,9",     
                    "0,1,2,7,8", "0,1,2,7,9", "0,1,2,8,9", "0,1,3,4,5", "0,1,3,4,6", "0,1,3,4,7",  
                    "0,1,3,4,8", "0,1,3,4,9", "0,1,3,5,6", "0,1,3,5,7", "0,1,3,5,8", "0,1,3,5,9",  
                    "0,1,3,6,7", "0,1,3,6,8", "0,1,3,6,9", "0,1,3,7,8", "0,1,3,7,9", "0,1,3,8,9",     
                    "0,1,4,5,6", "0,1,4,5,7", "0,1,4,5,8", "0,1,4,5,9", "0,1,4,6,7", "0,1,4,6,8",     
                    "0,1,4,6,9", "0,1,4,7,8", "0,1,4,7,9", "0,1,4,8,9", "0,1,5,6,7", "0,1,5,6,8",  
                    "0,1,5,7,9", "0,1,5,8,9", "0,1,6,7,8", "0,1,6,7,9", "0,1,6,8,9", "0,1,7,8,9",  
                    "0,2,3,4,7", "0,2,3,4,8", "0,2,3,4,9", "0,2,3,5,6", "0,2,3,5,7", "0,2,3,5,8",       
                    "0,2,3,6,8", "0,2,3,6,9", "0,2,3,7,8", "0,2,3,7,9", "0,2,3,8,9", "0,2,4,5,6",    
                    "0,2,4,6,8", "0,2,4,6,9", "0,2,4,7,8", "0,2,4,7,9", "0,2,4,8,9", "0,2,5,6,7",      
                    "0,2,5,7,8", "0,2,5,7,9", "0,2,5,8,9", "0,2,6,7,8", "0,2,6,7,9", "0,2,6,8,9",      
                    "1,2,3,4,6", "1,2,3,4,7", "1,2,3,4,8", "1,2,3,4,9", "1,2,3,5,6", "1,2,3,5,7",      
                    "1,2,3,6,8", "1,2,3,6,9", "1,2,3,7,8", "1,2,3,7,9", "1,2,3,8,9", "1,2,4,5,6",      
                    "1,2,4,5,9", "1,2,4,6,7", "1,2,4,6,8", "1,2,4,6,9", "1,2,4,7,8", "1,2,4,7,9",     
                    "1,2,5,6,8", "1,2,5,6,9", "1,2,5,7,8", "1,2,5,7,9", "1,2,5,8,9", "1,2,6,7,8",     
                    "1,2,6,7,9", "1,2,6,8,9", "1,2,7,8,9", "0,2,4,5,7", "0,2,4,5,8", "0,2,4,5,9",     
                    "0,2,4,6,7", "1,2,4,8,9", "1,2,5,6,7", "1,2,4,5,7", "1,2,4,5,8", "0,2,3,5,9",
                    "1,2,3,5,8", "1,2,3,5,9", "1,2,3,6,7", "0,2,7,8,9", "1,2,3,4,5", "0,2,3,6,7", 
                    "0,2,5,6,8", "0,2,5,6,9", "0,1,5,6,9", "0,1,5,7,8", "0,2,3,4,5", "0,2,3,4,6"
                ];
                
                console.log(`Total de combinações geradas: ${allCombinations.length}`);
                console.log(`Total de combinações válidas: ${validCombinations.length}`);
                
                return validCombinations;
            }

            // Gerar todas as combinações possíveis e filtrar as válidas
            const allPossibleCombinations = generateAllDigitCombinations();
            const validDigitCombinations = filterValidCombinations(allPossibleCombinations);
            
            // Fill the textarea with the valid combinations
            document.getElementById('digitCombinations').value = validDigitCombinations.join('\n');

            // Variáveis para armazenar todos os palpites gerados (para download)
            let allGeneratedBets = [];
            let lowBets = [];
            let mediumBets = [];
            let highBets = [];
            let validBetsCount = 0;

            // Variáveis para a funcionalidade de combinação específica
            let specificPossibleNumbers = [];
            let specificGeneratedBets = [];
            let currentPage = 1;
            const itemsPerPage = 12;
            
            // Variáveis para armazenar combinações não sorteadas
            let undrawnCombinations = [];

            // Configurar o toggle para a tabela de combinações
            const toggleHeader = document.getElementById('combinationsToggleHeader');
            const tableContainer = document.getElementById('combinationsTableContainer');
            const toggleBtn = toggleHeader.querySelector('.toggle-btn');
            
            toggleHeader.addEventListener('click', function() {
                toggleBtn.classList.toggle('active');
                
                if (tableContainer.style.maxHeight === '0px' || tableContainer.style.maxHeight === '') {
                    tableContainer.style.maxHeight = tableContainer.scrollHeight + 'px';
                } else {
                    tableContainer.style.maxHeight = '0px';
                }
            });

            // Preencher o dropdown de combinações específicas
            const specificComboSelect = document.getElementById('specificCombination');
            validDigitCombinations.forEach((combo, index) => {
                const option = document.createElement('option');
                option.value = combo;
                option.textContent = `#${index + 1}: ${combo}`;
                specificComboSelect.appendChild(option);
            });

            // Function to generate all possible two-digit numbers from the given digits
            function generateTwoDigitNumbers(digits, maxNumber) {
                const numbers = [];
                for (let i = 0; i < digits.length; i++) {
                    for (let j = 0; j < digits.length; j++) {
                        const num = parseInt(digits[i] + digits[j]);
                        // Add number if it's within range and not already in the list
                        if (num > 0 && num <= maxNumber && !numbers.includes(num)) {
                            numbers.push(num);
                        }
                    }
                }
                return numbers.sort((a, b) => a - b);
            }

            // Function to shuffle array (Fisher-Yates algorithm)
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            // Function to generate a balanced betting sequence with specified distribution
            function generateBalancedBettingSequence(possibleNumbers, numbersPerBet, lowCount, mediumCount, highCount) {
                if (possibleNumbers.length < numbersPerBet) {
                    return null; // Not enough numbers to form a complete bet
                }
                
                // Verify the sum of counts matches the total numbers per bet
                const totalRequested = lowCount + mediumCount + highCount;
                if (totalRequested !== numbersPerBet) {
                    console.warn(`Ajuste nos números solicitados: total ${totalRequested}, necessário ${numbersPerBet}`);
                    // Adjust counts proportionally
                    const factor = numbersPerBet / totalRequested;
                    lowCount = Math.round(lowCount * factor);
                    mediumCount = Math.round(mediumCount * factor);
                    highCount = numbersPerBet - lowCount - mediumCount;
                }
                
                // Categorize available numbers
                const lowNumbers = possibleNumbers.filter(num => num <= 10);
                const mediumNumbers = possibleNumbers.filter(num => num > 10 && num <= 20);
                const highNumbers = possibleNumbers.filter(num => num > 20);
                
                // Check if we have enough numbers in each category
                if (lowNumbers.length < lowCount || mediumNumbers.length < mediumCount || highNumbers.length < highCount) {
                    // Not enough numbers in required distribution, try to adjust
                    let deficit = 0;
                    let adjustedLowCount = Math.min(lowCount, lowNumbers.length);
                    deficit += lowCount - adjustedLowCount;
                    
                    let adjustedMediumCount = Math.min(mediumCount, mediumNumbers.length);
                    deficit += mediumCount - adjustedMediumCount;
                    
                    let adjustedHighCount = Math.min(highCount, highNumbers.length);
                    deficit += highCount - adjustedHighCount;
                    
                    // If we can't meet the deficit, return null
                    if (adjustedLowCount + adjustedMediumCount + adjustedHighCount + deficit > possibleNumbers.length) {
                        console.warn("Não é possível gerar palpite com a distribuição solicitada");
                        return null;
                    }
                    
                    // Distribute deficit among available categories
                    const remainingLow = lowNumbers.length - adjustedLowCount;
                    const remainingMedium = mediumNumbers.length - adjustedMediumCount;
                    const remainingHigh = highNumbers.length - adjustedHighCount;
                    
                    // Distribute deficit proportionally to remaining capacity
                    const totalRemaining = remainingLow + remainingMedium + remainingHigh;
                    if (totalRemaining > 0) {
                        const lowDeficit = Math.min(Math.round((remainingLow / totalRemaining) * deficit), remainingLow);
                        adjustedLowCount += lowDeficit;
                        deficit -= lowDeficit;
                        
                        const mediumDeficit = Math.min(Math.round((remainingMedium / totalRemaining) * deficit), remainingMedium);
                        adjustedMediumCount += mediumDeficit;
                        deficit -= mediumDeficit;
                        
                        // Assign any remaining deficit to high numbers
                        adjustedHighCount += deficit;
                    }
                    
                    lowCount = adjustedLowCount;
                    mediumCount = adjustedMediumCount;
                    highCount = adjustedHighCount;
                }
                
                // Shuffle each category to get random selection
                shuffleArray(lowNumbers);
                shuffleArray(mediumNumbers);
                shuffleArray(highNumbers);
                
                // Select required numbers from each category
                const selectedLow = lowNumbers.slice(0, lowCount);
                const selectedMedium = mediumNumbers.slice(0, mediumCount);
                const selectedHigh = highNumbers.slice(0, highCount);
                
                // Combine and sort for final bet
                return [...selectedLow, ...selectedMedium, ...selectedHigh].sort((a, b) => a - b);
            }

            // Function to format a number with leading zero if needed
            function formatNumber(num) {
                return num < 10 ? '0' + num : num.toString();
            }

            // Function to get number category class
            function getNumberCategoryClass(num) {
                if (num <= 10) return 'number-low';
                if (num <= 20) return 'number-medium';
                return 'number-high';
            }

            // Function to generate and display the results
            function generateResults() {
                const maxNumber = parseInt(document.getElementById('maxNumber').value);
                const numbersPerBet = parseInt(document.getElementById('numberPerBet').value);
                const lowRange = parseInt(document.getElementById('lowRange').value);
                const mediumRange = parseInt(document.getElementById('mediumRange').value);
                const highRange = parseInt(document.getElementById('highRange').value);
                
                const resultsContainer = document.getElementById('bettingResults');
                const tableBody = document.getElementById('combinationsTableBody');
                const statisticsContent = document.getElementById('statisticsContent');
                const statisticsTotal = document.getElementById('statisticsTotal');
                
                resultsContainer.innerHTML = '';
                tableBody.innerHTML = '';
                statisticsContent.innerHTML = '';
                
                // Reset the bet arrays and counter
                allGeneratedBets = [];
                lowBets = [];
                mediumBets = [];
                highBets = [];
                validBetsCount = 0;
                
                // Object to count how many combinations generate each number of possibilities
                const stats = {};
                let totalCombinations = 0;
                let lowCount = 0, mediumCount = 0, highCount = 0;
                
                validDigitCombinations.forEach((combination, index) => {
                    const digits = combination.split(',');
                    const possibleNumbers = generateTwoDigitNumbers(digits, maxNumber);
                    const count = possibleNumbers.length;
                    
                    // Update statistics
                    stats[count] = (stats[count] || 0) + 1;
                    totalCombinations++;
                    
                    // Add to combinations table
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td class="px-2 py-2">${combination}</td>
                        <td class="px-2 py-2">${possibleNumbers.map(formatNumber).join(' ')}</td>
                        <td class="px-2 py-2">${count}</td>
                    `;
                    tableBody.appendChild(row);

                    // Create balanced betting sequence
                    const bet = generateBalancedBettingSequence(possibleNumbers, numbersPerBet, lowRange, mediumRange, highRange);
                    
                    if (bet) {
                        validBetsCount++;
                        
                        // Count dezenas por categoria
                        const lowDezenas = bet.filter(num => num <= 10).length;
                        const mediumDezenas = bet.filter(num => num > 10 && num <= 20).length;
                        const highDezenas = bet.filter(num => num > 20).length;
                        
                        // Categorize the bet based on predominant type
                        let category;
                        if (lowDezenas >= mediumDezenas && lowDezenas >= highDezenas) {
                            category = 'low';
                            lowCount++;
                        } else if (mediumDezenas >= lowDezenas && mediumDezenas >= highDezenas) {
                            category = 'medium';
                            mediumCount++;
                        } else {
                            category = 'high';
                            highCount++;
                        }
                        
                        // Store the bet in the appropriate array
                        const betInfo = {
                            index: index + 1,
                            combination: combination,
                            numbers: bet.map(num => formatNumber(num)),
                            category: category,
                            possibleCount: count,
                            distribution: {
                                low: lowDezenas,
                                medium: mediumDezenas,
                                high: highDezenas
                            }
                        };
                        
                        allGeneratedBets.push(betInfo);
                        
                        if (category === 'low') lowBets.push(betInfo);
                        else if (category === 'medium') mediumBets.push(betInfo);
                        else if (category === 'high') highBets.push(betInfo);
                        
                        // Set category class
                        let categoryClass = '';
                        let categoryLabel = '';
                        
                        if (category === 'low') {
                            categoryClass = 'border-l-4 border-green-500';
                            categoryLabel = 'Baixas';
                        } else if (category === 'medium') {
                            categoryClass = 'border-l-4 border-yellow-500';
                            categoryLabel = 'Médias';
                        } else if (category === 'high') {
                            categoryClass = 'border-l-4 border-red-500';
                            categoryLabel = 'Altas';
                        }
                        
                        const card = document.createElement('div');
                        card.className = `bg-white dark:bg-gray-800 shadow rounded p-4 ${categoryClass} bet-card` + 
                                       ` ${category}-bet`; // Add class for filtering
                        
                        let numbersHTML = '';
                        bet.forEach(num => {
                            const categoryClass = getNumberCategoryClass(num);
                            numbersHTML += `<span class="inline-block ${categoryClass} rounded-full px-3 py-1 text-sm font-semibold">${formatNumber(num)}</span>`;
                        });
                        
                        card.innerHTML = `
                            <div class="font-semibold text-primary mb-2">Palpite #${index + 1} - Dígitos: ${combination}</div>
                            <div class="flex flex-wrap gap-2 mb-2">
                                ${numbersHTML}
                            </div>
                            <div class="flex justify-between items-center">
                                <div class="text-xs text-gray-500 dark:text-gray-400">
                                    <span class="text-green-600 dark:text-green-400">${lowDezenas} baixas</span> | 
                                    <span class="text-yellow-600 dark:text-yellow-400">${mediumDezenas} médias</span> | 
                                    <span class="text-red-600 dark:text-red-400">${highDezenas} altas</span>
                                </div>
                                <span class="px-2 py-1 text-xs rounded-full ${
                                    category === 'low' ? 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200' : 
                                    category === 'medium' ? 'bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200' : 
                                    'bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200'
                                }">${categoryLabel}</span>
                            </div>
                        `;
                        resultsContainer.appendChild(card);
                    } else {
                        const card = document.createElement('div');
                        card.className = 'bg-white dark:bg-gray-800 shadow rounded p-4';
                        card.innerHTML = `
                            <div class="font-semibold text-red-500 mb-2">Palpite #${index + 1} - Dígitos: ${combination}</div>
                            <div class="text-sm text-red-400">Não há números suficientes para formar um palpite equilibrado.</div>
                            <div class="text-xs text-gray-500 dark:text-gray-400">Total de números possíveis: ${count}</div>
                        `;
                        resultsContainer.appendChild(card);
                    }
                });
                
                // Update counters in the UI
                document.getElementById('lowCount').textContent = lowCount;
                document.getElementById('mediumCount').textContent = mediumCount;
                document.getElementById('highCount').textContent = highCount;
                document.getElementById('totalBetsCount').textContent = validBetsCount;
                
                // Generate statistics summary
                const sortedCounts = Object.keys(stats).sort((a, b) => parseInt(a) - parseInt(b));
                
                sortedCounts.forEach(count => {
                    const statItem = document.createElement('div');
                    statItem.className = 'bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded p-3';
                    statItem.innerHTML = `
                        <div class="font-semibold">${stats[count]} conjuntos de dígitos geram ${count} números</div>
                        <div class="text-sm mt-1">${stats[count] === 1 ? 'Representa' : 'Representam'} ${((stats[count] / totalCombinations) * 100).toFixed(1)}% do total</div>
                    `;
                    statisticsContent.appendChild(statItem);
                });
                
                // Add total
                statisticsTotal.innerHTML = `Total: ${totalCombinations} conjuntos de dígitos analisados`;
                
                // Ajusta a altura da tabela de combinações para quando o usuário quiser expandir
                setTimeout(() => {
                    tableContainer.style.maxHeight = tableContainer.scrollHeight + 'px';
                    // Volta a ocultar a tabela
                    setTimeout(() => {
                        tableContainer.style.maxHeight = '0px';
                    }, 100);
                }, 100);
            }

            // Função para gerar texto para download
            function generateDownloadText() {
                const maxNumber = parseInt(document.getElementById('maxNumber').value);
                const numbersPerBet = parseInt(document.getElementById('numberPerBet').value);
                const lowRange = parseInt(document.getElementById('lowRange').value);
                const mediumRange = parseInt(document.getElementById('mediumRange').value);
                const highRange = parseInt(document.getElementById('highRange').value);
                
                let text = `PALPITES GERADOS - DIA DE SORTE\n`;
                text += `Números por palpite: ${numbersPerBet} | Número máximo: ${maxNumber}\n`;
                text += `Distribuição pretendida: ${lowRange} baixas, ${mediumRange} médias, ${highRange} altas\n`;
                text += `Data de geração: ${new Date().toLocaleDateString()}\n\n`;
                
                // Adicionar estatísticas
                text += `RESUMO DOS PALPITES:\n`;
                text += `Total de palpites gerados: ${validBetsCount}\n`;
                text += `Palpites com predominância de dezenas baixas (1-10): ${document.getElementById('lowCount').textContent}\n`;
                text += `Palpites com predominância de dezenas médias (11-20): ${document.getElementById('mediumCount').textContent}\n`;
                text += `Palpites com predominância de dezenas altas (21-31): ${document.getElementById('highCount').textContent}\n\n`;
                
                // Adicionar palpites por categoria
                text += `=== PALPITES COM PREDOMINÂNCIA DE DEZENAS BAIXAS (1-10) ===\n\n`;
                lowBets.forEach(bet => {
                    text += `Palpite #${bet.index} - Dígitos: ${bet.combination}\n`;
                    text += `Números: ${bet.numbers.join(' ')}\n`;
                    text += `Distribuição: ${bet.distribution.low} baixas, ${bet.distribution.medium} médias, ${bet.distribution.high} altas\n\n`;
                });
                
                text += `=== PALPITES COM PREDOMINÂNCIA DE DEZENAS MÉDIAS (11-20) ===\n\n`;
                mediumBets.forEach(bet => {
                    text += `Palpite #${bet.index} - Dígitos: ${bet.combination}\n`;
                    text += `Números: ${bet.numbers.join(' ')}\n`;
                    text += `Distribuição: ${bet.distribution.low} baixas, ${bet.distribution.medium} médias, ${bet.distribution.high} altas\n\n`;
                });
                
                text += `=== PALPITES COM PREDOMINÂNCIA DE DEZENAS ALTAS (21-31) ===\n\n`;
                highBets.forEach(bet => {
                    text += `Palpite #${bet.index} - Dígitos: ${bet.combination}\n`;
                    text += `Números: ${bet.numbers.join(' ')}\n`;
                    text += `Distribuição: ${bet.distribution.low} baixas, ${bet.distribution.medium} médias, ${bet.distribution.high} altas\n\n`;
                });
                
                return text;
            }

            // Função para gerar texto simples para download (apenas os números)
            function generateSimpleDownloadText() {
                let text = '';
                
                // Apenas os números de cada palpite, separados por espaço
                allGeneratedBets.forEach(bet => {
                    text += bet.numbers.join(' ') + '\n';
                });
                
                return text;
            }
            
            // Função para gerar texto de download das combinações não sorteadas
            function generateUndrawnCombinationsText() {
                let text = `COMBINAÇÕES AINDA NÃO SORTEADAS - DIA DE SORTE\n`;
                text += `Data de extração: ${new Date().toLocaleDateString()}\n\n`;
                text += `Total de combinações não sorteadas: ${undrawnCombinations.length} de ${validDigitCombinations.length}\n\n`;
                
                text += undrawnCombinations.join('\n');
                
                return text;
            }
            
            // Função para download de combinações não sorteadas
            function downloadUndrawnCombinations() {
                if (undrawnCombinations.length === 0) {
                    alert('Não há combinações não sorteadas para baixar ou a análise ainda não foi realizada.');
                    return;
                }
                
                const textContent = generateUndrawnCombinationsText();
                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                // Criar um link temporário e simular clique
                const a = document.createElement('a');
                a.href = url;
                a.download = 'combinacoes_nao_sorteadas.txt';
                document.body.appendChild(a);
                a.click();
                
                // Limpar
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }

            // Função para download dos palpites detalhados
            function downloadBets() {
                if (allGeneratedBets.length === 0) {
                    alert('Gere os palpites primeiro antes de baixar.');
                    return;
                }
                
                const textContent = generateDownloadText();
                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                // Criar um link temporário e simular clique
                const a = document.createElement('a');
                a.href = url;
                a.download = 'palpites_dia_de_sorte.txt';
                document.body.appendChild(a);
                a.click();
                
                // Limpar
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }

            // Função para download dos palpites simplificados (apenas os números)
            function downloadSimpleBets() {
                if (allGeneratedBets.length === 0) {
                    alert('Gere os palpites primeiro antes de baixar.');
                    return;
                }
                
                const textContent = generateSimpleDownloadText();
                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                // Criar um link temporário e simular clique
                const a = document.createElement('a');
                a.href = url;
                a.download = 'palpites_simples.txt';
                document.body.appendChild(a);
                a.click();
                
                // Limpar
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }

            // Função para configurar paginação dos resultados específicos
            function setupPagination() {
                const totalPages = Math.ceil(specificGeneratedBets.length / itemsPerPage);
                const paginationInfo = document.getElementById('paginationInfo');
                const prevBtn = document.getElementById('prevPageBtn');
                const nextBtn = document.getElementById('nextPageBtn');
                
                // Atualizar informações de página
                paginationInfo.textContent = `Página ${currentPage} de ${totalPages || 1}`;
                
                // Habilitar/desabilitar botões
                prevBtn.disabled = currentPage <= 1;
                nextBtn.disabled = currentPage >= totalPages;
                
                // Mostrar resultados da página atual
                showSpecificBetsPage();
            }

            // Função para mostrar a página atual de palpites específicos
            function showSpecificBetsPage() {
                const startIndex = (currentPage - 1) * itemsPerPage;
                const endIndex = Math.min(startIndex + itemsPerPage, specificGeneratedBets.length);
                const resultsContainer = document.getElementById('specificResultsContainer');
                
                resultsContainer.innerHTML = '';
                
                // Se não há resultados
                if (specificGeneratedBets.length === 0) {
                    resultsContainer.innerHTML = `
                        <div class="col-span-full p-4 text-center text-gray-500 dark:text-gray-400">
                            Nenhum palpite gerado. Selecione uma combinação e clique em "Gerar Palpites".
                        </div>
                    `;
                    return;
                }
                
                // Mostrar palpites da página atual
                for (let i = startIndex; i < endIndex; i++) {
                    const bet = specificGeneratedBets[i];
                    const card = document.createElement('div');
                    card.className = 'bg-white dark:bg-gray-800 shadow rounded p-4';
                    
                    let numbersHTML = '';
                    bet.numbers.forEach(num => {
                        const parsedNum = parseInt(num);
                        const categoryClass = getNumberCategoryClass(parsedNum);
                        numbersHTML += `<span class="inline-block ${categoryClass} rounded-full px-3 py-1 text-sm font-semibold">${num}</span>`;
                    });
                    
                    const lowCount = bet.numbers.filter(n => parseInt(n) <= 10).length;
                    const mediumCount = bet.numbers.filter(n => parseInt(n) > 10 && parseInt(n) <= 20).length;
                    const highCount = bet.numbers.filter(n => parseInt(n) > 20).length;
                    
                    card.innerHTML = `
                        <div class="font-semibold text-primary mb-2">Palpite #${i + 1}</div>
                        <div class="flex flex-wrap gap-2 mb-2">
                            ${numbersHTML}
                        </div>
                        <div class="text-xs text-gray-500 dark:text-gray-400">
                            <span class="text-green-600 dark:text-green-400">${lowCount} baixas</span> | 
                            <span class="text-yellow-600 dark:text-yellow-400">${mediumCount} médias</span> | 
                            <span class="text-red-600 dark:text-red-400">${highCount} altas</span>
                        </div>
                    `;
                    resultsContainer.appendChild(card);
                }
            }

            // Função para gerar todas as combinações possíveis de K elementos em um array
            function generateCombinations(array, k) {
                const result = [];
                
                // Função recursiva para gerar combinações
                function backtrack(start, current) {
                    if (current.length === k) {
                        result.push([...current]);
                        return;
                    }
                    
                    for (let i = start; i < array.length; i++) {
                        current.push(array[i]);
                        backtrack(i + 1, current);
                        current.pop();
                    }
                }
                
                backtrack(0, []);
                return result;
            }

            // Função para mostrar os números possíveis para a combinação selecionada
            function updatePossibleNumbers() {
                const selectedCombo = document.getElementById('specificCombination').value;
                const maxNumber = parseInt(document.getElementById('maxNumber').value);
                const digits = selectedCombo.split(',');
                
                specificPossibleNumbers = generateTwoDigitNumbers(digits, maxNumber);
                
                // Atualizar a exibição dos números possíveis
                const display = document.getElementById('possibleNumbersDisplay');
                display.innerHTML = '';
                
                specificPossibleNumbers.forEach(num => {
                    const numStr = formatNumber(num);
                    const categoryClass = getNumberCategoryClass(num);
                    const span = document.createElement('span');
                    span.className = `inline-block ${categoryClass} rounded-full px-3 py-1 text-sm font-semibold`;
                    span.textContent = numStr;
                    display.appendChild(span);
                });
                
                // Limpar resultados anteriores
                specificGeneratedBets = [];
                document.getElementById('specificBetCount').textContent = '0';
                document.getElementById('specificResultsContainer').innerHTML = '';
                document.getElementById('downloadSpecificBtn').disabled = true;
                
                setupPagination();
            }

            // Função para gerar palpites para a combinação específica
            function generateSpecificBets() {
                const numbersPerBet = parseInt(document.getElementById('specificNumberPerBet').value);
                
                // Verificar se há números suficientes
                if (specificPossibleNumbers.length < numbersPerBet) {
                    alert(`Esta combinação gera apenas ${specificPossibleNumbers.length} números possíveis, o que é insuficiente para formar um palpite com ${numbersPerBet} dezenas.`);
                    return;
                }
                
                // Calcular todas as combinações possíveis
                const allCombos = generateCombinations(specificPossibleNumbers, numbersPerBet);
                specificGeneratedBets = allCombos.map(combo => ({
                    numbers: combo.map(num => formatNumber(num))
                }));
                
                // Atualizar contador e habilitar botão de download
                document.getElementById('specificBetCount').textContent = specificGeneratedBets.length;
                document.getElementById('downloadSpecificBtn').disabled = false;
                
                // Configurar paginação e mostrar resultados
                currentPage = 1;
                setupPagination();
            }

            // Função para gerar texto de download dos palpites específicos
            function generateSpecificDownloadText() {
                if (specificGeneratedBets.length === 0) return '';
                
                const selectedCombo = document.getElementById('specificCombination').value;
                const numbersPerBet = parseInt(document.getElementById('specificNumberPerBet').value);
                
                let text = `PALPITES GERADOS PARA COMBINAÇÃO DE DÍGITOS: ${selectedCombo}\n`;
                text += `Números por palpite: ${numbersPerBet}\n`;
                text += `Data de geração: ${new Date().toLocaleDateString()}\n\n`;
                text += `Total de palpites: ${specificGeneratedBets.length}\n\n`;
                
                // Adicionar cada palpite
                specificGeneratedBets.forEach((bet, index) => {
                    text += `Palpite #${index + 1}: ${bet.numbers.join(' ')}\n`;
                });
                
                return text;
            }

            // Função para download dos palpites específicos
            function downloadSpecificBets() {
                if (specificGeneratedBets.length === 0) {
                    alert('Nenhum palpite foi gerado para download.');
                    return;
                }
                
                const textContent = generateSpecificDownloadText();
                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                // Criar um link temporário e simular clique
                const a = document.createElement('a');
                a.href = url;
                a.download = 'palpites_específicos.txt';
                document.body.appendChild(a);
                a.click();
                
                // Limpar
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }

            // Configurar abas para filtrar os palpites
            function setupTabs() {
                const allTab = document.getElementById('allBetsTab');
                const lowTab = document.getElementById('lowBetsTab');
                const mediumTab = document.getElementById('mediumBetsTab');
                const highTab = document.getElementById('highBetsTab');
                
                // Função para atualizar a aparência das abas
                function updateTabAppearance(activeTab) {
                    // Remover estilos ativos de todas as abas
                    [allTab, lowTab, mediumTab, highTab].forEach(tab => {
                        tab.classList.remove('border-b-2', 'border-primary', 'text-primary');
                        tab.classList.add('text-gray-600', 'dark:text-gray-400');
                    });
                    
                    // Adicionar estilos à aba ativa
                    activeTab.classList.remove('text-gray-600', 'dark:text-gray-400');
                    activeTab.classList.add('border-b-2', 'border-primary', 'text-primary');
                }
                
                // Configurar manipuladores de eventos
                allTab.addEventListener('click', function() {
                    document.querySelectorAll('.bet-card').forEach(card => {
                        card.style.display = 'block';
                    });
                    updateTabAppearance(allTab);
                });
                
                lowTab.addEventListener('click', function() {
                    document.querySelectorAll('.bet-card').forEach(card => {
                        if (card.classList.contains('low-bet')) {
                            card.style.display = 'block';
                        } else {
                            card.style.display = 'none';
                        }
                    });
                    updateTabAppearance(lowTab);
                });
                
                mediumTab.addEventListener('click', function() {
                    document.querySelectorAll('.bet-card').forEach(card => {
                        if (card.classList.contains('medium-bet')) {
                            card.style.display = 'block';
                        } else {
                            card.style.display = 'none';
                        }
                    });
                    updateTabAppearance(mediumTab);
                });
                
                highTab.addEventListener('click', function() {
                    document.querySelectorAll('.bet-card').forEach(card => {
                        if (card.classList.contains('high-bet')) {
                            card.style.display = 'block';
                        } else {
                            card.style.display = 'none';
                        }
                    });
                    updateTabAppearance(highTab);
                });
            }

            // Add event listener for the generate button
            document.getElementById('generateBtn').addEventListener('click', function() {
                generateResults();
                setupTabs();
            });
            
            // Add event listener for the print button
            document.getElementById('printBtn').addEventListener('click', function() {
                window.print();
            });
            
            // Add event listener for the download buttons
            document.getElementById('downloadBtn').addEventListener('click', downloadBets);
            document.getElementById('downloadSimpleBtn').addEventListener('click', downloadSimpleBets);
            document.getElementById('downloadUndrawnBtn').addEventListener('click', downloadUndrawnCombinations);

            // Add event listener for the specific combination select
            document.getElementById('specificCombination').addEventListener('change', updatePossibleNumbers);
            
            // Add event listener for the generate specific button
            document.getElementById('generateSpecificBtn').addEventListener('click', generateSpecificBets);
            
            // Add event listener for the download specific button
            document.getElementById('downloadSpecificBtn').addEventListener('click', downloadSpecificBets);
            
            // Add event listeners for pagination
            document.getElementById('prevPageBtn').addEventListener('click', function() {
                if (currentPage > 1) {
                    currentPage--;
                    setupPagination();
                }
            });
            
            document.getElementById('nextPageBtn').addEventListener('click', function() {
                const totalPages = Math.ceil(specificGeneratedBets.length / itemsPerPage);
                if (currentPage < totalPages) {
                    currentPage++;
                    setupPagination();
                }
            });

            // Function to extract digits from a number
            function getDigits(num) {
                return num.toString().padStart(2, '0').split('').map(Number);
            }

            // Function to analyze the frequency of digit combinations in historical results
            function analyzeFrequency() {
                const resultsText = document.getElementById('historicalResults').value.trim();
                if (!resultsText) {
                    alert('Por favor, insira os resultados históricos.');
                    return;
                }

                const results = [];
                const lines = resultsText.split('\n');

                // Parse each line of results
                for (const line of lines) {
                    if (line.trim() === '') continue;
                    
                    const numbers = line.trim().split(/\s+/).map(n => parseInt(n.trim()));
                    if (numbers.length >= 7) { // Ensure there are at least 7 numbers (Dia de Sorte standard)
                        results.push(numbers);
                    }
                }

                if (results.length === 0) {
                    alert('Nenhum resultado válido encontrado. Verifique o formato.');
                    return;
                }

                // Count digit occurrences in each result
                const digitCombinationCounts = {};
                
                // Inicializar contadores para todas as combinações possíveis
                validDigitCombinations.forEach(combo => {
                    digitCombinationCounts[combo] = 0;
                });
                
                // Iterate through each result
                results.forEach(result => {
                    // Get all digits from all numbers in this result
                    const allDigits = new Set();
                    result.forEach(num => {
                        getDigits(num).forEach(digit => allDigits.add(digit));
                    });
                    
                    // Convert to array and sort
                    const digitsArray = Array.from(allDigits).sort((a, b) => a - b);
                    
                    // Only consider results with 5 or more distinct digits
                    if (digitsArray.length >= 5) {
                        // Verificar quais das combinações válidas estão presentes neste resultado
                        validDigitCombinations.forEach(combo => {
                            const comboDigits = combo.split(',').map(Number);
                            
                            // Verificar se todos os dígitos da combinação estão presentes
                            if (comboDigits.every(digit => digitsArray.includes(digit))) {
                                digitCombinationCounts[combo]++;
                            }
                        });
                    }
                });

                // Convert to array for sorting
                const combinationsArray = Object.entries(digitCombinationCounts)
                    .map(([combo, count]) => ({ combo, count }))
                    .sort((a, b) => b.count - a.count);

                // Identificar combinações que ainda não foram sorteadas
                undrawnCombinations = validDigitCombinations.filter(combo => 
                    digitCombinationCounts[combo] === 0
                );
                
                // Display results
                const frequencyResults = document.getElementById('frequencyResults');
                const frequencyTableBody = document.getElementById('frequencyTableBody');
                const topCombinations = document.getElementById('topCombinations');
                const undrawnCombinationsContent = document.getElementById('undrawnCombinationsContent');

                frequencyResults.classList.remove('hidden');
                frequencyTableBody.innerHTML = '';
                undrawnCombinationsContent.innerHTML = '';
                
                if (combinationsArray.length === 0) {
                    topCombinations.innerHTML = 'Nenhuma combinação de 5 dígitos encontrada nos resultados.';
                    return;
                }

                // Show the top combinations with highlighting for 5 digits
                const top5Combos = combinationsArray.filter(item => item.count > 0).slice(0, 5);
                
                let topCombosHTML = `
                    <div class="font-bold text-xl mb-3">Combinações de 5 Dígitos Mais Frequentes</div>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                `;
                
                top5Combos.forEach((item, index) => {
                    const percentage = ((item.count / results.length) * 100).toFixed(1);
                    topCombosHTML += `
                        <div class="bg-green-100 dark:bg-green-900 p-3 rounded-lg border-2 border-green-500">
                            <div class="font-bold text-lg text-green-800 dark:text-green-200">${index + 1}. ${item.combo}</div>
                            <div class="text-green-700 dark:text-green-300">
                                ${item.count} de ${results.length} resultados (${percentage}%)
                            </div>
                        </div>
                    `;
                });
                
                topCombosHTML += `</div>`;
                
                // Adicionar informação sobre combinações que ainda não apareceram
                topCombosHTML += `
                    <div class="mt-4 p-3 bg-yellow-100 dark:bg-yellow-900 rounded-lg">
                        <div class="font-bold text-yellow-800 dark:text-yellow-200">
                            ${undrawnCombinations.length} combinações ainda não apareceram em nenhum sorteio (de um total de ${validDigitCombinations.length})
                        </div>
                    </div>
                `;
                
                topCombinations.innerHTML = topCombosHTML;
                
                // Mostrar as combinações não sorteadas
                if (undrawnCombinations.length > 0) {
                    undrawnCombinations.forEach(combo => {
                        const comboDiv = document.createElement('div');
                        comboDiv.className = 'bg-blue-50 dark:bg-blue-800 p-2 rounded border border-blue-200 dark:border-blue-700';
                        comboDiv.innerHTML = `<div class="text-blue-800 dark:text-blue-200 font-medium">${combo}</div>`;
                        undrawnCombinationsContent.appendChild(comboDiv);
                    });
                    
                    document.getElementById('undrawnCombinations').style.display = 'block';
                } else {
                    document.getElementById('undrawnCombinations').style.display = 'none';
                }

                // Fill the frequency table with all combinations that appeared
                combinationsArray.filter(item => item.count > 0).forEach(({ combo, count }) => {
                    const percentage = ((count / results.length) * 100).toFixed(1);
                    
                    const row = document.createElement('tr');
                    
                    // Destacar as combinações de 5 dígitos
                    row.classList.add('bg-green-100', 'dark:bg-green-800');
                    row.innerHTML = `
                        <td class="px-2 py-2 font-bold">${combo}</td>
                        <td class="px-2 py-2 font-bold">${count} de ${results.length}</td>
                        <td class="px-2 py-2 font-bold">${percentage}%</td>
                    `;
                    
                    frequencyTableBody.appendChild(row);
                });
                
                // Atualizar o dropdown para priorizar combinações não sorteadas
                if (undrawnCombinations.length > 0) {
                    // Limpar o dropdown
                    specificComboSelect.innerHTML = '';
                    
                    // Adicionar as combinações não sorteadas primeiro com um destaque
                    undrawnCombinations.forEach((combo, index) => {
                        const option = document.createElement('option');
                        option.value = combo;
                        option.textContent = `★ [Não Sorteada] ${combo}`;
                        option.style.fontWeight = 'bold';
                        option.style.color = '#1e40af';  // Cor azul mais escura
                        specificComboSelect.appendChild(option);
                    });
                    
                    // Adicionar as combinações que já saíram depois
                    validDigitCombinations.filter(combo => !undrawnCombinations.includes(combo))
                        .forEach((combo, index) => {
                            const option = document.createElement('option');
                            option.value = combo;
                            option.textContent = `${combo} (${digitCombinationCounts[combo]} vezes)`;
                            specificComboSelect.appendChild(option);
                        });
                    
                    // Disparar evento change para atualizar a exibição
                    specificComboSelect.dispatchEvent(new Event('change'));
                }
            }

            // Add event listener for analyze button
            document.getElementById('analyzeBtn').addEventListener('click', analyzeFrequency);
            
            // ======== FUNÇÕES DE ACESSO À API ========
            
            // Função genérica para tentar acessar uma URL via múltiplos proxies CORS
            async function fetchViaProxy(baseUrl, customHeaders = {}) {
                // Tenta cada proxy disponível
                for (const proxyUrl of API_CONFIG.CORS_PROXY_URLS) {
                    try {
                        // Constrói a URL com o proxy
                        const url = proxyUrl.includes('?url=') ? 
                            `${proxyUrl}${encodeURIComponent(baseUrl)}` : 
                            `${proxyUrl}${baseUrl}`;
                        
                        console.log(`Tentando via proxy: ${url}`);
                        
                        const response = await fetch(url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                ...customHeaders
                            },
                            mode: 'cors'
                        });
                        
                        if (response.ok) {
                            return await response.json();
                        }
                    } catch (proxyError) {
                        console.log(`Proxy falhou (${proxyUrl}):`, proxyError);
                        // Continua para o próximo proxy
                    }
                }
                
                throw new Error('Nenhum proxy CORS conseguiu acessar a URL');
            }

            // ===== API CAIXA =====
            async function fetchFromCaixaAPI(concursoNum = null, useProxy = false) {
                try {
                    // Verificar cache primeiro
                    const cacheKey = concursoNum ? 
                        `caixa_dia_de_sorte_${concursoNum}` : 
                        'caixa_dia_de_sorte_latest';
                    
                    const cachedData = LOCAL_CACHE.getCached(cacheKey);
                    
                    if (cachedData) {
                        console.log('Usando dados em cache para:', cacheKey);
                        return {
                            success: true,
                            message: `Sucesso! Dados obtidos do cache local (${cachedData.length} concursos).`,
                            formattedResults: cachedData.join('\n'),
                            source: 'cache'
                        };
                    }
                    
                    // Constrói a URL baseada no parâmetro de concurso
                    const url = concursoNum ? 
                        `${API_CONFIG.CAIXA_URL}/${concursoNum}` : 
                        API_CONFIG.CAIXA_URL;
                    
                    let data;
                    
                    if (useProxy) {
                        // Acesso via proxy CORS
                        console.log(`Buscando dados da Caixa via proxy: ${url}`);
                        data = await fetchViaProxy(url, {
                            'Origin': 'https://loterias.caixa.gov.br',
                            'Referer': 'https://loterias.caixa.gov.br/'
                        });
                    } else {
                        // Acesso direto
                        console.log(`Buscando dados da Caixa diretamente: ${url}`);
                        const response = await fetch(url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json',
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                                'Origin': 'https://loterias.caixa.gov.br',
                                'Referer': 'https://loterias.caixa.gov.br/'
                            },
                            mode: 'cors',
                            credentials: 'omit'
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Status HTTP: ${response.status}`);
                        }
                        
                        data = await response.json();
                    }
                    
                    console.log("Resposta da API Caixa:", data);
                    
                    if (data && data.listaDezenas && Array.isArray(data.listaDezenas)) {
                        const allResults = [data.listaDezenas.join(' ')];
                        LOCAL_CACHE.setCached(cacheKey, allResults, 60); // Cache por 60 minutos
                        
                        return {
                            success: true,
                            message: `Sucesso! Dados obtidos da API oficial da Caixa (concurso ${data.numero}) ${useProxy ? 'via proxy' : 'diretamente'}.`,
                            formattedResults: allResults.join('\n'),
                            source: useProxy ? 'caixa-proxy' : 'caixa'
                        };
                    } else {
                        throw new Error('Formato de dados inválido ou inesperado');
                    }
                } catch (error) {
                    console.error(`Erro ao acessar API Caixa ${useProxy ? 'via proxy' : 'diretamente'}:`, error);
                    return {
                        success: false,
                        message: `Falha na API Caixa ${useProxy ? '(via proxy)' : '(acesso direto)'}: ${error.message}`
                    };
                }
            }
            
            // ===== API HEROKU =====
            async function fetchFromHerokuAPI(useProxy = false) {
                try {
                    // Verificar cache primeiro
                    const cacheKey = 'heroku_dia_de_sorte';
                    const cachedData = LOCAL_CACHE.getCached(cacheKey);
                    
                    if (cachedData) {
                        console.log('Usando dados em cache para Heroku API');
                        return {
                            success: true,
                            message: 'Sucesso! Dados obtidos do cache local (API Heroku).',
                            formattedResults: cachedData,
                            source: 'cache'
                        };
                    }
                    
                    let data;
                    
                    if (useProxy) {
                        // Acesso via proxy CORS
                        console.log(`Buscando dados da Heroku API via proxy`);
                        data = await fetchViaProxy(API_CONFIG.HEROKU_URL);
                    } else {
                        // Acesso direto  
                        console.log(`Buscando dados da Heroku API diretamente`);
                        const response = await fetch(API_CONFIG.HEROKU_URL, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Status ${response.status}`);
                        }
                        
                        data = await response.json();
                    }
                    
                    console.log("Resposta da API Heroku:", data);
                    
                    if (data && Array.isArray(data)) {
                        const formattedResults = data.map(contest => {
                            return contest.dezenas.join(' ');
                        }).join('\n');
                        
                        // Armazenar em cache
                        LOCAL_CACHE.setCached(cacheKey, formattedResults, 60); // Cache por 60 minutos
                        
                        return {
                            success: true,
                            message: `Sucesso! Dados obtidos da API Heroku (${data.length} concursos) ${useProxy ? 'via proxy' : 'diretamente'}.`,
                            formattedResults: formattedResults,
                            source: useProxy ? 'heroku-proxy' : 'heroku'
                        };
                    } else {
                        throw new Error('Formato de dados inválido');
                    }
                } catch (error) {
                    console.error(`Erro ao acessar API Heroku ${useProxy ? 'via proxy' : 'diretamente'}:`, error);
                    return {
                        success: false,
                        message: `Falha na API Heroku ${useProxy ? '(via proxy)' : '(acesso direto)'}: ${error.message}`
                    };
                }
            }
            
            // ===== API BRASIL =====
            async function fetchFromBrasilAPI(useProxy = false) {
                try {
                    // Verificar cache primeiro
                    const cacheKey = 'brasil_dia_de_sorte';
                    const cachedData = LOCAL_CACHE.getCached(cacheKey);
                    
                    if (cachedData) {
                        console.log('Usando dados em cache para Brasil API');
                        return {
                            success: true,
                            message: 'Sucesso! Dados obtidos do cache local (API Brasil).',
                            formattedResults: cachedData,
                            source: 'cache'
                        };
                    }
                    
                    let data;
                    
                    if (useProxy) {
                        // Acesso via proxy CORS
                        console.log(`Buscando dados da Brasil API via proxy`);
                        data = await fetchViaProxy(API_CONFIG.BRASIL_URL);
                    } else {
                        // Acesso direto
                        console.log(`Buscando dados da Brasil API diretamente`);
                        const response = await fetch(API_CONFIG.BRASIL_URL, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Status ${response.status}`);
                        }
                        
                        data = await response.json();
                    }
                    
                    console.log("Resposta da API Brasil:", data);
                    
                    if (data && data.concursos && Array.isArray(data.concursos)) {
                        const formattedResults = data.concursos.map(contest => {
                            return contest.numeros.join(' ');
                        }).join('\n');
                        
                        // Armazenar em cache
                        LOCAL_CACHE.setCached(cacheKey, formattedResults, 60);
                        
                        return {
                            success: true,
                            message: `Sucesso! Dados obtidos da API Brasil (${data.concursos.length} concursos) ${useProxy ? 'via proxy' : 'diretamente'}.`,
                            formattedResults: formattedResults,
                            source: useProxy ? 'brasil-proxy' : 'brasil'
                        };
                    } else {
                        throw new Error('Formato de dados inválido');
                    }
                } catch (error) {
                    console.error(`Erro ao acessar API Brasil ${useProxy ? 'via proxy' : 'diretamente'}:`, error);
                    return {
                        success: false,
                        message: `Falha na API Brasil ${useProxy ? '(via proxy)' : '(acesso direto)'}: ${error.message}`
                    };
                }
            }
            
            // Função principal para buscar resultados de acordo com as configurações do usuário
            async function fetchResultsFromAPIs() {
                const spinner = document.getElementById('loadingSpinner');
                const fetchText = document.getElementById('fetchText');
                const apiStatus = document.getElementById('apiStatus');
                const apiStatusContent = document.getElementById('apiStatusContent');
                const apiSelect = document.getElementById('apiSelect');
                const modeSelect = document.getElementById('modeSelect');
                
                const selectedAPI = apiSelect.value;
                const accessMode = modeSelect.value; // direct, proxy, or both
                
                // Obter o número do concurso (se fornecido)
                const concursoInput = document.getElementById('concursoNum');
                const concursoNum = concursoInput.value ? parseInt(concursoInput.value) : null;
                
                // Show loading spinner and status
                spinner.classList.remove('hidden');
                fetchText.textContent = 'Buscando...';
                apiStatus.classList.remove('hidden');
                apiStatusContent.innerHTML = 'Iniciando busca de resultados...';
                
                if (concursoNum) {
                    apiStatusContent.innerHTML += `<br>Buscando dados do concurso ${concursoNum}...`;
                }
                
                // Clear any previous results
                document.getElementById('historicalResults').value = '';
                
                try {
                    // Se uma API específica foi selecionada
                    if (selectedAPI !== 'auto') {
                        apiStatusContent.innerHTML += `<br>API selecionada: ${selectedAPI}`;
                        
                        let result = null;
                        
                        // Tenta obter dados de acordo com o modo selecionado
                        if (accessMode === 'direct' || accessMode === 'both') {
                            apiStatusContent.innerHTML += '<br>Tentando acesso direto...';
                            
                            switch (selectedAPI) {
                                case 'caixa':
                                    result = await fetchFromCaixaAPI(concursoNum, false);
                                    break;
                                case 'heroku':
                                    result = await fetchFromHerokuAPI(false);
                                    break;
                                case 'brasilapi':
                                    result = await fetchFromBrasilAPI(false);
                                    break;
                            }
                            
                            if (result && result.success) {
                                apiStatusContent.innerHTML += `<br>✅ ${result.message}`;
                                document.getElementById('historicalResults').value = result.formattedResults;
                                analyzeFrequency();
                                
                                spinner.classList.add('hidden');
                                fetchText.textContent = 'Buscar Resultados';
                                return;
                            } else if (result) {
                                apiStatusContent.innerHTML += `<br>❌ ${result.message}`;
                            }
                        }
                        
                        // Se o modo direto falhou ou foi pulado, tenta via proxy
                        if (accessMode === 'proxy' || accessMode === 'both') {
                            apiStatusContent.innerHTML += '<br>Tentando acesso via proxy CORS...';
                            
                            switch (selectedAPI) {
                                case 'caixa':
                                    result = await fetchFromCaixaAPI(concursoNum, true);
                                    break;
                                case 'heroku':
                                    result = await fetchFromHerokuAPI(true);
                                    break;
                                case 'brasilapi':
                                    result = await fetchFromBrasilAPI(true);
                                    break;
                            }
                            
                            if (result && result.success) {
                                apiStatusContent.innerHTML += `<br>✅ ${result.message}`;
                                document.getElementById('historicalResults').value = result.formattedResults;
                                analyzeFrequency();
                                
                                spinner.classList.add('hidden');
                                fetchText.textContent = 'Buscar Resultados';
                                return;
                            } else if (result) {
                                apiStatusContent.innerHTML += `<br>❌ ${result.message}`;
                            }
                        }
                        
                        // Se chegou aqui, todas as tentativas falharam
                        apiStatusContent.innerHTML += '<br>❌ Todas as tentativas falharam para a API selecionada.';
                        apiStatusContent.innerHTML += '<br>⚠️ Tente outra API ou modifique os parâmetros da busca.';
                    } else {
                        // Modo automático - tenta todas as APIs
                        apiStatusContent.innerHTML += '<br>Modo automático: testando múltiplas APIs...';
                        
                        // Array com todas as combinações de API e modo de acesso para tentar
                        const apiOptions = [
                            // Primeiro tenta Heroku (geralmente mais confiável)
                            { name: 'heroku', fn: fetchFromHerokuAPI, params: [false], label: 'Heroku (direto)' },
                            { name: 'heroku', fn: fetchFromHerokuAPI, params: [true], label: 'Heroku (proxy)' },
                            
                            // Depois Caixa
                            { name: 'caixa', fn: fetchFromCaixaAPI, params: [concursoNum, false], label: 'Caixa (direto)' },
                            { name: 'caixa', fn: fetchFromCaixaAPI, params: [concursoNum, true], label: 'Caixa (proxy)' },
                            
                            // Por último Brasil
                            { name: 'brasilapi', fn: fetchFromBrasilAPI, params: [false], label: 'Brasil (direto)' },
                            { name: 'brasilapi', fn: fetchFromBrasilAPI, params: [true], label: 'Brasil (proxy)' }
                        ];
                        
                        // Tentar cada combinação de API e modo de acesso
                        for (const option of apiOptions) {
                            apiStatusContent.innerHTML += `<br>Tentando API ${option.label}...`;
                            
                            try {
                                const result = await option.fn(...option.params);
                                
                                if (result.success) {
                                    apiStatusContent.innerHTML += `<br>✅ ${result.message}`;
                                    document.getElementById('historicalResults').value = result.formattedResults;
                                    analyzeFrequency();
                                    
                                    spinner.classList.add('hidden');
                                    fetchText.textContent = 'Buscar Resultados';
                                    return;
                                } else {
                                    apiStatusContent.innerHTML += `<br>❌ ${result.message}`;
                                }
                            } catch (apiError) {
                                apiStatusContent.innerHTML += `<br>❌ Erro inesperado: ${apiError.message}`;
                            }
                        }
                        
                        // Se chegou aqui, todas as APIs falharam
                        apiStatusContent.innerHTML += '<br>❌ Todas as APIs falharam.';
                        apiStatusContent.innerHTML += '<br>⚠️ Sugestões:';
                        apiStatusContent.innerHTML += '<br>1. Verifique sua conexão com a internet';
                        apiStatusContent.innerHTML += '<br>2. Tente novamente mais tarde';
                        apiStatusContent.innerHTML += '<br>3. Insira manualmente os resultados da loteria';
                    }
                } catch (error) {
                    apiStatusContent.innerHTML += `<br>❌ Erro geral: ${error.message}`;
                    apiStatusContent.innerHTML += '<br>⚠️ Por favor, tente novamente ou insira os dados manualmente.';
                } finally {
                    spinner.classList.add('hidden');
                    fetchText.textContent = 'Buscar Resultados';
                }
            }
            
            // Add event listener for fetching results
            document.getElementById('fetchResultsBtn').addEventListener('click', fetchResultsFromAPIs);

            // Generate results on page load
            generateResults();
            setupTabs();
            updatePossibleNumbers(); // Inicializar a tela de combinação específica
        });
    </script>
    
    <footer>Feito por: <i>Márcio Fernando Maia -  Todos os direitos reservado - 2025</i></footer>
</body>
</html>